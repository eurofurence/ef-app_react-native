import { randomUUID } from 'expo-crypto'
import { createContext, ReactNode, useCallback, useContext, useState } from 'react'

/**
 * A toast message entry.
 */
export type ToastMessage = {
    /**
     * The ID of this toast, autogenerated, not stable.
     */
    id: string;

    /**
     * The type of the toast.
     */
    type: 'notice' | 'info' | 'warning' | 'error';

    /**
     * The content, can be a React node.
     */
    content: ReactNode | string;

    /**
     * The time at which the message was queued.
     */
    queued: number;

    /**
     * The lifetime at initialization.
     */
    lifetime: number;

    /**
     * A group key, freely pickable if multiple consumers render toasts.
     */
    group?: any;
};

/**
 * Type of the toast context.
 */
export type ToastContextType = {
    /**
     * Current toast messages.
     */
    messages: ToastMessage[];

    /**
     * Offers a toast for presentation.
     * @param type The type of the toast.
     * @param content The content, can be a React node.
     * @param lifetime The lifetime.
     * @param group A group key, freely pickable if multiple consumers render toasts.
     */
    toast(type: 'notice' | 'info' | 'warning' | 'error', content: ReactNode | string, lifetime?: number, group?: any): void;

    /**
     * Dismisses a toast.
     * @param id The ID of the toast.
     */
    dismiss(id: string): void;
};

/**
 * Toast context object.
 */
export const ToastContext = createContext<ToastContextType>({
    messages: [],
    toast() {
    },
    dismiss() {
    },
})
ToastContext.displayName = 'ToastContext'

/**
 * Prop types for a toast provider.
 */
export type ToastContextProviderProps = {
    /**
     * The children to provide for.
     */
    children?: ReactNode | undefined;
};

/**
 * Provides toast management.
 * @param children The children to provide for.
 * @constructor
 */
export const ToastContextProvider = ({ children }: ToastContextProviderProps) => {
    const [messages, setMessages] = useState<ToastMessage[]>([])
    const toast = useCallback((type: 'notice' | 'info' | 'warning' | 'error', content: ReactNode | string, lifetime = 5000, group?: any) => {
        const queued = Date.now()
        const message = { id: randomUUID(), type, content, queued, lifetime, group }

        setMessages((current) => [...current, message])
        setTimeout(() => {
            setMessages((current) => {
                const i = current.indexOf(message)
                return i < 0 ? current : current.slice(0, i).concat(current.slice(i + 1))
            })
        }, lifetime)
    }, [])

    const dismiss = useCallback((id: string) => {
        setMessages((current) => {
            const i = current.findIndex((message) => id === message.id)
            return i < 0 ? current : current.slice(0, i).concat(current.slice(i + 1))
        })
    }, [])

    return <ToastContext.Provider value={{ messages, toast, dismiss }}>{children}</ToastContext.Provider>
}

/**
 * Uses the entire toast context.
 */
export const useToastContext = () => useContext(ToastContext)

/**
 * Uses the toast method of the toast context.
 */
export const useToast = () => useContext(ToastContext).toast

/**
 * Uses the toast dismiss method of the toast context.
 */
export const useToastDismiss = () => useContext(ToastContext).dismiss

/**
 * Uses the current messages of the toast context.
 */
export const useToastMessages = (limit?: number) => {
    const result = useContext(ToastContext).messages

    if (limit === undefined) return result
    const start = Math.max(result.length - limit, 0)
    const end = Math.min(start + limit, result.length)
    return result.slice(start, end)
}
